[2025-04-23 00:07:29]
import customtkinter as ctk
from tkinter import filedialog
from datetime import datetime
import csv
import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# ---- choose ONE collector implementation ----------------------------
# from collector import TweetCollector      # Tweepy (needs API quota)
try:
    from addons.bypass_collector import TweetCollector   # snscrape / nitter fallback
except ImportError:
    TweetCollector = None  # offline mode only

from addons.analyzer import SentimentAnalyzer

class Page2(ctk.CTkFrame):
    """Opinion‑polling page with live or offline (CSV) mode."""

    def __init__(self, parent):
        super().__init__(parent)

        # --- state holders -------------------------------------------------
        self.collector = None
        self.analyzer = None
        self.countdown_job = None

        self.sentiment_counts = {"Positive": [], "Neutral": [], "Negative": []}
        self.time_stamps: list[str] = []

        # --- UI ------------------------------------------------------------
        ctk.CTkLabel(self, text="Real‑Time Opinion Polling", font=("Arial", 20)).pack(pady=10)

        self.entry = ctk.CTkEntry(self, placeholder_text="#Hashtag", width=240)
        self.entry.pack(pady=6)

        self.status = ctk.CTkLabel(self, text="Idle", text_color="gray")
        self.status.pack()

        btn_row = ctk.CTkFrame(self)
        btn_row.pack(pady=6)
        ctk.CTkButton(btn_row, text="Start Monitoring", command=self.start_monitoring).pack(side="left", padx=4)
        ctk.CTkButton(btn_row, text="Stop", fg_color="#8b0000", command=self.stop_monitoring).pack(side="left", padx=4)
        ctk.CTkButton(btn_row, text="Load CSV", fg_color="#006400", command=self.load_csv).pack(side="left", padx=4)

        self.fig_frame = ctk.CTkFrame(self)
        self.fig_frame.pack(pady=12)
        self.canvas = None
        self.trend_canvas = None
        self.example_textbox = None

    # ------------------------------------------------------------------
    # Live monitoring
    # ------------------------------------------------------------------
    def start_monitoring(self):
        if TweetCollector is None:
            self.status.configure(text="Collector module missing", text_color="red")
            return

        hashtag = self.entry.get().strip()
        if not hashtag:
            self.status.configure(text="Enter a hashtag first!", text_color="red")
            return

        self.stop_monitoring()  # ensure clean slate

        self.collector = TweetCollector(hashtag, cooldown=60)
        self.collector.start()

        self.analyzer = SentimentAnalyzer(
            self.collector.csv_path,
            update_callback=self.on_new_analysis,
            reload_every=30,
        )
        self.analyzer.start()

        self.status.configure(text="Collecting…", text_color="orange")
        self._schedule_countdown()

    def stop_monitoring(self):
        if self.collector:
            self.collector.stop(); self.collector = None
        if self.analyzer:
            self.analyzer.stop(); self.analyzer = None
        if self.countdown_job:
            self.after_cancel(self.countdown_job); self.countdown_job = None
        self.status.configure(text="Stopped", text_color="gray")

    def _schedule_countdown(self):
        if not self.collector:
            return
        sec = self.collector.seconds_until_next_request()
        if sec > 0:
            self.status.configure(text=f"Collecting… (⏳ {sec}s)", text_color="orange")
        else:
            self.status.configure(text="Collecting…", text_color="orange")
        self.countdown_job = self.after(1000, self._schedule_countdown)

    # ------------------------------------------------------------------
    # Analyzer callback (live mode)
    # ------------------------------------------------------------------
    def on_new_analysis(self, new_rows):
        pos = sum(r["sentiment"] == "Positive" for r in new_rows)
        neu = sum(r["sentiment"] == "Neutral" for r in new_rows)
        neg = sum(r["sentiment"] == "Negative" for r in new_rows)
        ts = datetime.now().strftime("%H:%M:%S")
        self.time_stamps.append(ts)
        self.sentiment_counts["Positive"].append(pos)
        self.sentiment_counts["Neutral"].append(neu)
        self.sentiment_counts["Negative"].append(neg)
        self.update_pie_chart()
        self.update_trend_chart()
        self.status.configure(text="Analyzing…", text_color="green")

    # ------------------------------------------------------------------
    # Offline CSV loader
    # ------------------------------------------------------------------
    def load_csv(self):
        path = filedialog.askopenfilename(filetypes=[("CSV", "*.csv")])
        if not path:
            return

        # stop live threads if running
        self.stop_monitoring()

        # reset state
        self.sentiment_counts = {"Positive": [], "Neutral": [], "Negative": []}
        self.time_stamps.clear()

        with open(path, encoding="utf-8") as f:
            reader = csv.DictReader(f)
            rows = [r for r in reader]

        # aggregate trend by minute
        buckets = {}
        sample_map = {"Positive": [], "Neutral": [], "Negative": []}
        for r in rows:
                        # Parse timestamps that may be with or without seconds
            try:
                dt = datetime.strptime(r["Date"], "%Y-%m-%d %H:%M:%S")
            except ValueError:
                dt = datetime.strptime(r["Date"], "%Y-%m-%d %H:%M")
            minute = dt.strftime("%H:%M")
            buckets.setdefault(minute, {"Positive":0, "Neutral":0, "Negative":0})
            buckets[minute][r["Sentiment"]] += 1
            if len(sample_map[r["Sentiment"]]) < 3:
                sample_map[r["Sentiment"]].append(r["Tweet"][:120] + "…")

        for minute in sorted(buckets):
            self.time_stamps.append(minute)
            self.sentiment_counts["Positive"].append(buckets[minute]["Positive"])
            self.sentiment_counts["Neutral"].append(buckets[minute]["Neutral"])
            self.sentiment_counts["Negative"].append(buckets[minute]["Negative"])

        self.update_pie_chart()
        self.update_trend_chart()
        self._show_samples(sample_map)
        self.status.configure(text=f"Loaded {len(rows)} tweets from {os.path.basename(path)}", text_color="green")

    # ------------------------------------------------------------------
    # Visualization helpers (reuse for both modes)
    # ------------------------------------------------------------------
    def update_pie_chart(self):
        """Dark‑theme pie chart with inline labels."""
        if self.canvas:
            self.canvas.get_tk_widget().destroy()

        totals = {k: sum(v) for k, v in self.sentiment_counts.items()}
        labels, values = zip(*totals.items()) if totals else ([], [])

        fig, ax = plt.subplots(figsize=(4, 3))
        dark = "#2B2B2B"
        fig.patch.set_facecolor(dark)
        ax.set_facecolor(dark)

        if values:
            ax.pie(values, labels=labels, autopct="%1.1f%%", startangle=90, textprops={"color": "white"})
        ax.set_title("Sentiment Share", color="white")

        self.canvas = FigureCanvasTkAgg(fig, master=self.fig_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(side="left")
        plt.close(fig)

    def update_trend_chart(self):
        """Dark‑theme line chart with inline labels at latest points."""
        if self.trend_canvas:
            self.trend_canvas.get_tk_widget().destroy()
        if not self.time_stamps:
            return

        history = np.array([
            self.sentiment_counts["Positive"],
            self.sentiment_counts["Neutral"],
            self.sentiment_counts["Negative"],
        ])
        colors = ["#4caf50", "#ffb300", "#e91e63"]  # green, amber, pink
        labels = ["Positive", "Neutral", "Negative"]

        fig, ax = plt.subplots(figsize=(6, 4))
        dark = "#2B2B2B"
        fig.patch.set_facecolor(dark)
        ax.set_facecolor(dark)

        for series, color, label in zip(history, colors, labels):
            ax.plot(self.time_stamps, series, marker="o", color=color)
            if series:
                ax.text(self.time_stamps[-1], series[-1], f" {label}", color=color, va="center", fontsize=8)

        ax.set_title("Sentiment Trend Over Time", color="white")
        ax.set_xlabel("Time (HH:MM)", color="white")
        ax.set_ylabel("Tweet Count", color="white")
        ax.tick_params(axis="x", rotation=45, labelcolor="white")
        ax.tick_params(axis="y", labelcolor="white")
        ax.grid(True, linestyle="--", alpha=0.3, color="white")
        fig.tight_layout()

        self.trend_canvas = FigureCanvasTkAgg(fig, master=self.fig_frame)
        self.trend_canvas.draw()
        self.trend_canvas.get_tk_widget().pack(side="left")
        plt.close(fig)

    def _show_samples(self, sample_map):
        if self.example_textbox:
            self.example_textbox.destroy()
        self.example_textbox = ctk.CTkTextbox(self, width=700, height=200)
        self.example_textbox.pack(pady=8)
        for sent, tweets in sample_map.items():
            self.example_textbox.insert("end", f"{sent} examples:\n")
            for t in tweets:
                self.example_textbox.insert("end", f"  - {t}\n")
            self.example_textbox.insert("end", "\n")
        self.example_textbox.configure(state="disabled")
  Negative: 22.42%
  Neutral: 72.39%
  Positive: 5.19%

